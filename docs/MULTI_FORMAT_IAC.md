# Multi-Format IaC Code Generation

Scaffold AI now supports generating infrastructure code in multiple formats:

## Supported Formats

### 1. AWS CDK (TypeScript) - Default
- **File:** `packages/generated/infrastructure/lib/scaffold-ai-stack.ts`
- **Benefits:**
  - Type-safe infrastructure code
  - L2 constructs with built-in best practices
  - Easy to test and refactor
  - Native AWS support
- **Use when:** Building new AWS applications with TypeScript/Node.js

### 2. CloudFormation (YAML)
- **File:** `packages/generated/infrastructure/template.yaml`
- **Benefits:**
  - Native AWS format
  - No additional tooling required
  - AWS Serverless Application Model (SAM) support
  - Direct deployment with AWS CLI
- **Use when:** Working with existing CloudFormation stacks or AWS SAM

### 3. Terraform (HCL)
- **File:** `packages/generated/infrastructure/main.tf`
- **Benefits:**
  - Multi-cloud support
  - Large ecosystem of providers
  - State management
  - Popular in enterprise environments
- **Use when:** Managing multi-cloud infrastructure or using Terraform already

## How to Use

### Frontend

Select your preferred IaC format from the dropdown in the chat interface:

```
┌─────────────────────────────────────┐
│ [CDK (TypeScript)        ▼]         │
│ [CloudFormation (YAML)   ▼]         │
│ [Terraform (HCL)         ▼]         │
└─────────────────────────────────────┘
```

### API

Send the `iac_format` parameter in your chat request:

```typescript
const response = await fetch("/api/chat", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    message: "Build a REST API with database",
    graph: graphJSON,
    iac_format: "terraform", // "cdk", "cloudformation", or "terraform"
  }),
});
```

### Backend

The format is passed through the workflow state:

```python
initial_state: GraphState = {
    "user_input": request.user_input,
    "intent": "generate_code",
    "graph_json": request.graph_json,
    "iac_format": request.iac_format,  # "cdk", "cloudformation", or "terraform"
    "generated_files": [],
    "response": "",
}
```

## Implementation

### Architecture

```
Frontend (Select) → API Route → FastAPI → Workflow → Specialist Agent
                                                           ↓
                                          ┌────────────────┴────────────────┐
                                          ▼                ▼                ▼
                                    CDKSpecialist  CloudFormation    Terraform
                                                   Specialist        Specialist
```

### Specialist Agents

Each format has a dedicated specialist agent:

1. **CDKSpecialistAgent** (`agents/cdk_specialist.py`)
   - Generates TypeScript CDK code
   - Uses LLM for intelligent code generation
   - Applies security best practices

2. **CloudFormationSpecialistAgent** (`agents/cloudformation_specialist.py`)
   - Generates YAML CloudFormation templates
   - Uses AWS::Serverless transform
   - Includes outputs for all resources

3. **TerraformSpecialistAgent** (`agents/terraform_specialist.py`)
   - Generates HCL Terraform configuration
   - Includes provider configuration
   - Adds IAM roles and policies

## Example Output

### CDK (TypeScript)

```typescript
import * as cdk from 'aws-cdk-lib';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
import * as lambda from 'aws-cdk-lib/aws-lambda';

export class ScaffoldAiStack extends cdk.Stack {
  constructor(scope: cdk.App, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    const table = new dynamodb.Table(this, 'DataTable', {
      partitionKey: { name: 'id', type: dynamodb.AttributeType.STRING },
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      encryption: dynamodb.TableEncryption.AWS_MANAGED,
      pointInTimeRecovery: true,
    });

    const fn = new lambda.Function(this, 'ApiHandler', {
      runtime: lambda.Runtime.NODEJS_20_X,
      handler: 'index.handler',
      code: lambda.Code.fromAsset('lambda'),
      tracing: lambda.Tracing.ACTIVE,
    });

    table.grantReadWriteData(fn);
  }
}
```

### CloudFormation (YAML)

```yaml
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Generated by Scaffold AI

Resources:
  DataTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true

  ApiHandler:
    Type: AWS::Serverless::Function
    Properties:
      Runtime: nodejs20.x
      Handler: index.handler
      CodeUri: ./src
      Tracing: Active
      Policies:
        - DynamoDBCrudPolicy:
            TableName: !Ref DataTable

Outputs:
  TableName:
    Value: !Ref DataTable
  FunctionArn:
    Value: !GetAtt ApiHandler.Arn
```

### Terraform (HCL)

```hcl
terraform {
  required_version = ">= 1.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

resource "aws_dynamodb_table" "data" {
  name         = "data-table"
  billing_mode = "PAY_PER_REQUEST"
  hash_key     = "id"

  attribute {
    name = "id"
    type = "S"
  }

  point_in_time_recovery {
    enabled = true
  }

  server_side_encryption {
    enabled = true
  }
}

resource "aws_lambda_function" "api_handler" {
  function_name = "api-handler"
  runtime       = "nodejs20.x"
  handler       = "index.handler"
  filename      = "function.zip"
  role          = aws_iam_role.lambda_role.arn

  tracing_config {
    mode = "Active"
  }
}

resource "aws_iam_role" "lambda_role" {
  name = "api-handler-role"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Action = "sts:AssumeRole"
      Effect = "Allow"
      Principal = {
        Service = "lambda.amazonaws.com"
      }
    }]
  })
}

output "table_name" {
  value       = aws_dynamodb_table.data.name
  description = "Name of DynamoDB table"
}

output "function_arn" {
  value       = aws_lambda_function.api_handler.arn
  description = "ARN of Lambda function"
}
```

## Security

All formats include security best practices:

- ✅ Encryption at rest (DynamoDB, S3)
- ✅ Encryption in transit (API Gateway)
- ✅ IAM least privilege
- ✅ Tracing enabled (X-Ray)
- ✅ Point-in-time recovery (DynamoDB)
- ✅ Public access blocked (S3)

The security gate validates architectures before code generation regardless of format.

## Files Modified

### Backend
- `src/scaffold_ai/graph/state.py` - Added `iac_format` field
- `src/scaffold_ai/graph/nodes.py` - Updated `cdk_specialist_node` to support multiple formats
- `src/scaffold_ai/main.py` - Added `iac_format` to `ChatRequest`
- `src/scaffold_ai/agents/cloudformation_specialist.py` - New CloudFormation agent
- `src/scaffold_ai/agents/terraform_specialist.py` - New Terraform agent

### Frontend
- `components/Chat.tsx` - Added format selector dropdown
- `app/api/chat/route.ts` - Pass `iac_format` to backend

## Future Enhancements

- [ ] Pulumi support (TypeScript, Python, Go)
- [ ] CDK Python support
- [ ] Bicep support (Azure)
- [ ] Format conversion (CDK → Terraform, etc.)
- [ ] Multi-stack architectures
- [ ] Custom templates per format

## Testing

Test the feature by:

1. Start the backend: `cd apps/backend && uv run uvicorn scaffold_ai.main:app --reload`
2. Start the frontend: `cd apps/web && pnpm dev`
3. Open http://localhost:3000
4. Select a format from the dropdown
5. Send a message: "Build a REST API with database"
6. Check the generated code in the response

---

**Added:** February 17, 2026
**Status:** ✅ Implemented and tested
